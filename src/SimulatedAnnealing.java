import java.util.ArrayList;
import java.util.IntSummaryStatistics;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Simulated Annealing Simulation Manager
 */
public class SimulatedAnnealing extends SimulationManager{
    private final int numItemsToRemove = 1;
    private final double coolingRate;
    private SACandidate bestCandidate;
    private SACandidate candidate;
    private double temperature;

    /**
     * Constructor.
     * Initialize a random confiuration.
     * @param config - SA configuration for this SA Instance.
     */
    public SimulatedAnnealing(SimulatedAnnealingConfiguration config) {
        this.temperature = config.getInitialTemperature();
        this.coolingRate = config.getCoolingRate();
        this.candidate = new SACandidate().withRandomlySelectedItems().withFitnessCalculated();
        this.bestCandidate = candidate;
    } 

    /**
     * Execute an iteration of Simulated Annealing.
     */
    public Knapsack execute(){
        int currentEnergy = this.candidate.calculateEnergy();

        SACandidate newCandidate = getNewSolution();
        int newCandidateEnergy = newCandidate.calculateEnergy();
        
        if(acceptanceProbability(currentEnergy, newCandidateEnergy, this.temperature) > Configuration.RANDOM_GENERATOR.nextDouble()){
            candidate = newCandidate;
        }

        if(newCandidate.calculateEnergy() > this.bestCandidate.calculateEnergy()){
            this.bestCandidate = newCandidate;
            this.bestCandidate.updateFitness();
        }

        this.temperature *= (1 - this.coolingRate);
    
        if(this.temperature < 1)
            return null;
    
        return this.bestCandidate;
    }

    /**
     * Probability of accepting the 
     */
    private double acceptanceProbability(int currentEnergy, int newEnergy, double temperature) {
        if (newEnergy < currentEnergy) {
            return 1;
        }
        return Math.exp((currentEnergy - newEnergy) / temperature);
    }

    /**
     * New solution is generated by removing SimulatedAnnealing.numItemsToRemove from the knapsack
     * and then adding random items in until adding a new item would exceed the max capacity.
     * @return
     */
    private SACandidate getNewSolution(){
        SACandidate candidateCopy = new SACandidate(Knapsack.copyBoolArrayList(candidate.getKnapsackSelection()));
        candidateCopy = removeItems(candidateCopy, this.numItemsToRemove);
        addItems(candidateCopy);
        return candidateCopy;
    }

    /**
     * Remove [remove] items from the candidate.
     * @param candidate - the candidate solution.
     * @param remove - number of items to remove.
     */
    private SACandidate removeItems(SACandidate candidate, int remove){
        List<KnapsackItem> items = candidate.mapFromBinaryRepresentation(candidate.getKnapsackSelection());
        for(int i = 0; i < remove; i++){
            if(items.size() != 0){
                int rand = Configuration.RANDOM_GENERATOR.nextInt(items.size());
                items.remove(rand);     
            }
        }
        return new SACandidate(mapToBinaryRepresentation(items));
    }

    /**
     * Add as many items into the knapsack as possible randomly.
     * @param candidate - the candidate knapsack
     * @return SACandidate - knapsack with items added in
     */
    private SACandidate addItems(SACandidate candidate){
        List<Integer> numbersSelected = candidate.mapFromBinaryRepresentation(candidate.getKnapsackSelection()).stream()
            .map(k -> k.getNumber())
            .collect(Collectors.toList());

        List<KnapsackItem> unselectedItems = Configuration.KNAPSACK_ITEM_SELECTION.stream()
            .map(k -> k.clone())
            .filter(k -> !numbersSelected.contains(k.getNumber()))
            .collect(Collectors.toList());

        int numUnselectedItems = unselectedItems.size();
        for(int i = 0; i < numUnselectedItems; i++){
            int rand = Configuration.RANDOM_GENERATOR.nextInt(unselectedItems.size());
            KnapsackItem unselectedItem = unselectedItems.get(rand);

            if(candidate.calculateWeight() + unselectedItem.getWeight() < Configuration.MAX_CAPACITY){
                candidate.getKnapsackSelection().set(unselectedItem.getNumber() - 1, true);
            }

            unselectedItems.remove(unselectedItem);
        }
        return candidate;
    }

    /**
     * View summary stats for a given population state.
     * @return IntSummaryStatistics - summary statistics.
     * Note: This doesn't work well for SA. Here, count is the temperature, min is the candidate fitness,
     * max is the bestCandidate fitness and sum=0.
     */
    public IntSummaryStatistics getSummaryStats(){
        return new IntSummaryStatistics((int)this.temperature, this.candidate.calculateFitness(), this.bestCandidate.calculateFitness(), 0);
    }

    /**
     * Map from a Knapsack object list to a binary represenation
     * @param knapsackItems - Knapsack object list
     * @return ArrayList<Boolean> - binary represenation
     */
    private ArrayList<Boolean> mapToBinaryRepresentation(List<KnapsackItem> knapsackItems){
        ArrayList<Boolean> binaryKnapsackItems = new ArrayList<>();
        for(int i = 0; i < Configuration.NUM_ITEMS; i++){
            binaryKnapsackItems.add(false);
        }

        List<Integer> numbers = knapsackItems.stream()
            .map(sack -> sack.getNumber())
            .collect(Collectors.toList());

        for(int number : numbers){
            binaryKnapsackItems.set((number - 1), true);
        }
        return binaryKnapsackItems;
    }
}