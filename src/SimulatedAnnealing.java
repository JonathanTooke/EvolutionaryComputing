import java.util.ArrayList;
import java.util.IntSummaryStatistics;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Simulated Annealing Simulation Manager
 */
public class SimulatedAnnealing extends SimulationManager{
    private final double coolingRate;
    private SACandidate bestCandidate;
    private SACandidate candidate;
    private double temperature;
    private final int numItemsToRemove = 1;

    /**
     * Constructor.
     * Initialize a random confiuration.
     * @param config - SA configuration for this SA Instance.
     */
    public SimulatedAnnealing(SimulatedAnnealingConfiguration config) {
        this.temperature = config.getInitialTemperature();
        this.coolingRate = config.getCoolingRate();
        this.candidate = new SACandidate().withRandomlySelectedItems().withFitnessCalculated();
        this.bestCandidate = candidate;
    } 

    /**
     * Execute an iteration of Simulated Annealing.
     */
    public Knapsack execute(){
        if(this.temperature < 1)
            return null;

        int currentEnergy = this.candidate.calculateEnergy();

        SACandidate newCandidate = getNewSolution();
        int newCandidateEnergy = newCandidate.calculateEnergy();
        
        if(acceptanceProbability(currentEnergy, newCandidateEnergy, this.temperature) > Configuration.RANDOM_GENERATOR.nextDouble()){
            candidate = newCandidate;
        }

        if(newCandidate.calculateEnergy() > this.bestCandidate.calculateEnergy()){
            this.bestCandidate = newCandidate;
            this.bestCandidate.updateFitness();
        }

        this.temperature *= (1 - this.coolingRate);
    
        return this.bestCandidate;
    }

    /**
     * Probability of accepting the new candidate as the current candidate
     * @return 1 if the new candidate is better, otherwise a decimal as calculated below
     */
    private double acceptanceProbability(int currentEnergy, int newEnergy, double temperature) {
        if (newEnergy < currentEnergy) {
            return 1;
        }
        return Math.exp((currentEnergy - newEnergy) / temperature);
    }

    /**
     * New solution is generated by removing SimulatedAnnealing.numItemsToRemove from the knapsack
     * and then adding random items in until the bag cannot accept another item.
     * @return
     */
    private SACandidate getNewSolution(){
        SACandidate candidateCopy = new SACandidate(Knapsack.copyBoolArrayList(candidate.getKnapsackSelection()));
        candidateCopy = removeItems(candidateCopy, this.numItemsToRemove);
        addItems(candidateCopy);
        return candidateCopy;
    }

    /**
     * Remove [remove] items from the candidate.
     * @param candidate - the candidate solution.
     * @param remove - number of items to remove.
     */
    private SACandidate removeItems(SACandidate candidate, int remove){
        List<KnapsackItem> items = candidate.mapFromBinaryRepresentation(candidate.getKnapsackSelection());
        for(int i = 0; i < remove; i++){
            if(items.size() != 0){
                int rand = Configuration.RANDOM_GENERATOR.nextInt(items.size());
                items.remove(rand);     
            }
        }
        return new SACandidate(mapToBinaryRepresentation(items));
    }

    /**
     * Add as many items into the knapsack as possible randomly.
     * @param candidate - the candidate knapsack
     * @return SACandidate - knapsack with items added in
     */
    private SACandidate addItems(SACandidate candidate){
        List<Integer> numbersSelected = candidate.mapFromBinaryRepresentation(candidate.getKnapsackSelection()).stream()
            .map(k -> k.getNumber())
            .collect(Collectors.toList());

        List<KnapsackItem> unselectedItems = Configuration.KNAPSACK_ITEM_SELECTION.stream()
            .map(k -> k.clone())
            .filter(k -> !numbersSelected.contains(k.getNumber()))
            .collect(Collectors.toList());

        int numUnselectedItems = unselectedItems.size();
        for(int i = 0; i < numUnselectedItems; i++){
            int rand = Configuration.RANDOM_GENERATOR.nextInt(unselectedItems.size());
            KnapsackItem unselectedItem = unselectedItems.get(rand);

            if(candidate.calculateWeight() + unselectedItem.getWeight() < Configuration.MAX_CAPACITY){
                candidate.getKnapsackSelection().set(unselectedItem.getNumber() - 1, true);
            }

            unselectedItems.remove(unselectedItem);
        }
        return candidate;
    }

    /**
     * View summary stats for a given population state.
     * @return IntSummaryStatistics - summary statistics.
     * Note: This doesn't work well for SA. Here, count is the temperature, min is the candidate fitness,
     * max is the bestCandidate fitness and sum=0.
     */
    public IntSummaryStatistics getSummaryStats(){
        return new IntSummaryStatistics((int)this.temperature, this.candidate.calculateFitness(), this.bestCandidate.calculateFitness(), 0);
    }

    /**
     * Map from a Knapsack object list to a binary represenation
     * @param knapsackItems - Knapsack object list
     * @return ArrayList<Boolean> - binary represenation
     */
    private ArrayList<Boolean> mapToBinaryRepresentation(List<KnapsackItem> knapsackItems){
        ArrayList<Boolean> binaryKnapsackItems = new ArrayList<>();
        for(int i = 0; i < Configuration.NUM_ITEMS; i++){
            binaryKnapsackItems.add(false);
        }

        List<Integer> numbers = knapsackItems.stream()
            .map(sack -> sack.getNumber())
            .collect(Collectors.toList());

        for(int number : numbers){
            binaryKnapsackItems.set((number - 1), true);
        }
        return binaryKnapsackItems;
    }

    // /**
    //  * Alternative neighbor solution generator (bit flip mutation) - but less effective overall than the one currently implemented.
    //  * Remove or add an item to the knapsack until it is valid.
    //  * @return SACandidate - new solution.
    //  */
    // private SACandidate getNewSolution(){
    //     while(true){
    //         ArrayList<Boolean> newSelection = Knapsack.copyBoolArrayList(this.candidate.getKnapsackSelection());
    //         int itemToMutate = Configuration.RANDOM_GENERATOR.nextInt(newSelection.size());
    //         newSelection.set(itemToMutate, !newSelection.get(itemToMutate));

    //         SACandidate mutatedKnapsack = new SACandidate(newSelection).withFitnessCalculated();
    //         if(mutatedKnapsack.isValid())
    //             return mutatedKnapsack;
    //     }
    // }
} 
